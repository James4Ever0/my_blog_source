<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2022-12-16">
<meta name="description" content="This article discusses the use of Pyro and PyTorch for tasks such as text generation, object detection, and image watermark removal. The first comment focuses on the importance of hidden states in generating text using Pyro, while the second comment emphasizes training custom datasets and employing RNN/Transformer models for natural language generation with PyTorch.">

<title>James’ Blog - chatgpt on pyro and pytorch</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">James’ Blog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html" rel="" target="">
 <span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/james4ever0" rel="" target=""><i class="bi bi-github" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">chatgpt on pyro and pytorch</h1>
  <div class="quarto-categories">
    <div class="quarto-category">Pyro</div>
    <div class="quarto-category">Text generation</div>
    <div class="quarto-category">PyTorch</div>
    <div class="quarto-category">Object detection</div>
    <div class="quarto-category">Image watermark removal</div>
    <div class="quarto-category">Hidden states</div>
    <div class="quarto-category">Custom datasets</div>
  </div>
  </div>

<div>
  <div class="description">
    This article discusses the use of Pyro and PyTorch for tasks such as text generation, object detection, and image watermark removal. The first comment focuses on the importance of hidden states in generating text using Pyro, while the second comment emphasizes training custom datasets and employing RNN/Transformer models for natural language generation with PyTorch.
  </div>
</div>


<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">December 16, 2022</p>
    </div>
  </div>
  
    
  </div>
  

</header>

<hr>
<p>you better train a chatgpt yourself. understand the algorithm.</p>
<p>codegeex is not there yet. maybe you can fine-tune it a little bit?</p>
<section id="use-pyro-to-create-a-natural-language-generator" class="level2">
<h2 class="anchored" data-anchor-id="use-pyro-to-create-a-natural-language-generator">use pyro to create a natural language generator</h2>
<p>Pyro is a probabilistic programming language built on top of PyTorch, which can be used for creating probabilistic models and conducting Bayesian inference. One way you can use Pyro to create a natural language generator is by defining a probabilistic model of the language generation process, and using Monte Carlo sampling or variational inference to generate text.</p>
<p>Here is a basic example of how you might do this using Pyro:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pyro</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pyro.distributions <span class="im">as</span> dist</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Define the vocabulary and size of the language model</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>vocab <span class="op">=</span> [<span class="st">"&lt;START&gt;"</span>, <span class="st">"the"</span>, <span class="st">"cat"</span>, <span class="st">"sat"</span>, <span class="st">"on"</span>, <span class="st">"mat"</span>, <span class="st">"&lt;END&gt;"</span>]</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>vocab_size <span class="op">=</span> <span class="bu">len</span>(vocab)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Define a simple language model that generates text one word at a time</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> language_model(prefix):</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Initialize the hidden state with a uniform distribution</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>hidden_state <span class="op">=</span> pyro.sample(<span class="st">"hidden_state"</span>, dist.Uniform(<span class="dv">0</span>, vocab_size))</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Initialize the output sequence with the start token</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>output_sequence <span class="op">=</span> [vocab.index(<span class="st">"&lt;START&gt;"</span>)]</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Iterate over the prefix and append each word to the output sequence</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> word <span class="kw">in</span> prefix:</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>output_sequence.append(vocab.index(word))</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate the rest of the sequence one word at a time</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> output_sequence[<span class="op">-</span><span class="dv">1</span>] <span class="op">!=</span> vocab.index(<span class="st">"&lt;END&gt;"</span>):</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Use the hidden state to generate a distribution over the next word</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>next_word_dist <span class="op">=</span> pyro.sample(<span class="st">"next_word"</span>, dist.Categorical(hidden_state))</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="co"># Append the next word to the output sequence</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>output_sequence.append(next_word_dist)</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a><span class="co"># Update the hidden state using the next word</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>hidden_state <span class="op">=</span> pyro.sample(<span class="st">"hidden_state"</span>, dist.Uniform(<span class="dv">0</span>, vocab_size), obs<span class="op">=</span>next_word_dist)</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a><span class="co"># Convert the output sequence to a list of words</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a><span class="cf">return</span> [vocab[i] <span class="cf">for</span> i <span class="kw">in</span> output_sequence]</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate text using the language model</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>generated_text <span class="op">=</span> language_model(prefix<span class="op">=</span>[<span class="st">"the"</span>, <span class="st">"cat"</span>])</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(generated_text)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This example defines a simple language model that generates text one word at a time, using a hidden state to produce a distribution over the next word in the sequence. The model starts by initializing the hidden state with a uniform distribution, and then iteratively generates words until it reaches the end token. You can use Monte Carlo sampling or variational inference to generate text from this model by calling pyro.sample on the model and specifying the desired number of samples.</p>
<p>I hope this helps! Let me know if you have any questions.</p>
</section>
<section id="use-pyro-to-create-a-natural-language-generator-with-loss-function-like-adam" class="level2">
<h2 class="anchored" data-anchor-id="use-pyro-to-create-a-natural-language-generator-with-loss-function-like-adam">use pyro to create a natural language generator, with loss function like adam</h2>
<p>To use Pyro to create a natural language generator with a loss function like Adam, you will need to define a probabilistic model that takes in some input data and generates text, and then define a loss function that compares the generated text to some target text. You can then use an optimization algorithm like Adam to minimize the loss function and optimize the parameters of your model.</p>
<p>Here is an example of how you might do this using Pyro:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pyro</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pyro.distributions <span class="im">as</span> dist</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pyro.optim <span class="im">import</span> Adam</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Define the vocabulary and size of the language model</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>vocab <span class="op">=</span> [<span class="st">"&lt;START&gt;"</span>, <span class="st">"the"</span>, <span class="st">"cat"</span>, <span class="st">"sat"</span>, <span class="st">"on"</span>, <span class="st">"mat"</span>, <span class="st">"&lt;END&gt;"</span>]</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>vocab_size <span class="op">=</span> <span class="bu">len</span>(vocab)</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Define a simple language model that generates text one word at a time</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> language_model(prefix):</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Initialize the hidden state with a uniform distribution</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>hidden_state <span class="op">=</span> pyro.sample(<span class="st">"hidden_state"</span>, dist.Uniform(<span class="dv">0</span>, vocab_size))</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Initialize the output sequence with the start token</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>output_sequence <span class="op">=</span> [vocab.index(<span class="st">"&lt;START&gt;"</span>)]</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Iterate over the prefix and append each word to the output sequence</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> word <span class="kw">in</span> prefix:</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>output_sequence.append(vocab.index(word))</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate the rest of the sequence one word at a time</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> output_sequence[<span class="op">-</span><span class="dv">1</span>] <span class="op">!=</span> vocab.index(<span class="st">"&lt;END&gt;"</span>):</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Use the hidden state to generate a distribution over the next word</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>next_word_dist <span class="op">=</span> pyro.sample(<span class="st">"next_word"</span>, dist.Categorical(hidden_state))</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a><span class="co"># Append the next word to the output sequence</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>output_sequence.append(next_word_dist)</span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a><span class="co"># Update the hidden state using the next word</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>hidden_state <span class="op">=</span> pyro.sample(<span class="st">"hidden_state"</span>, dist.Uniform(<span class="dv">0</span>, vocab_size), obs<span class="op">=</span>next_word_dist)</span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a><span class="co"># Convert the output sequence to a list of words</span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a><span class="cf">return</span> [vocab[i] <span class="cf">for</span> i <span class="kw">in</span> output_sequence]</span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a><span class="co"># Define a loss function that compares the generated text to some target text</span></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> loss_fn(generated_text, target_text):</span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute the cross-entropy loss between the generated text and the target text</span></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a><span class="cf">return</span> <span class="op">-</span>torch.<span class="bu">sum</span>(torch.tensor([vocab.index(word) <span class="cf">for</span> word <span class="kw">in</span> target_text]) <span class="op">*</span> torch.log(torch.tensor([vocab.index(word) <span class="cf">for</span> word <span class="kw">in</span> generated_text])))</span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a><span class="co"># Optimize the parameters of the language model using Adam</span></span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a>optimizer <span class="op">=</span> Adam({<span class="st">"lr"</span>: <span class="fl">0.001</span>})</span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a><span class="co"># Set the number of training iterations</span></span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a>num_iterations <span class="op">=</span> <span class="dv">1000</span></span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a><span class="co"># Use Pyro's SVI to optimize the parameters of the language model</span></span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(num_iterations):</span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a><span class="co"># Clear the gradient</span></span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a>optimizer.zero_grad()</span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate some text using the language model</span></span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true" tabindex="-1"></a>generated_text <span class="op">=</span> language_model(prefix<span class="op">=</span>[<span class="st">"the"</span>, <span class="st">"cat"</span>])</span>
<span id="cb2-41"><a href="#cb2-41" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute the loss</span></span>
<span id="cb2-42"><a href="#cb2-42" aria-hidden="true" tabindex="-1"></a>loss <span class="op">=</span> loss_fn(generated_text, target_text)</span>
<span id="cb2-43"><a href="#cb2-43" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute the gradients</span></span>
<span id="cb2-44"><a href="#cb2-44" aria-hidden="true" tabindex="-1"></a>loss.backward()</span>
<span id="cb2-45"><a href="#cb2-45" aria-hidden="true" tabindex="-1"></a><span class="co"># Update the parameters</span></span>
<span id="cb2-46"><a href="#cb2-46" aria-hidden="true" tabindex="-1"></a>optimizer.step()</span>
<span id="cb2-47"><a href="#cb2-47" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate text using the optimized language model</span></span>
<span id="cb2-48"><a href="#cb2-48" aria-hidden="true" tabindex="-1"></a>generated_text <span class="op">=</span> language_model(prefix<span class="op">=</span>[<span class="st">"the"</span>, <span class="st">"cat"</span>])</span>
<span id="cb2-49"><a href="#cb2-49" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(generated_text)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This code uses Pyro’s Stochastic Variational Inference (SVI) to optimize the parameters of the language model using the Adam optimizer. The model is trained by generating text using the current parameters of the model, computing the loss between the generated text and the target text, and then updating the parameters based on the gradients of the loss with respect to the model parameters.</p>
<p>After training, you can use the optimized language model to generate text by calling language_model with the desired prefix as input.</p>
<p>I hope this helps! Let me know if you have any questions.</p>
</section>
<section id="use-pyro-to-generate-natural-language-using-advanced-models" class="level2">
<h2 class="anchored" data-anchor-id="use-pyro-to-generate-natural-language-using-advanced-models">use pyro to generate natural language using advanced models</h2>
<p>There are several advanced probabilistic models that you can use with Pyro to generate natural language. Some examples include:</p>
<p>Recurrent neural network (RNN) language models: These models use an RNN to process the input sequence and generate a probability distribution over the next word in the sequence. You can use Pyro to define an RNN language model by using the pyro.nn module to define the RNN and the pyro.distributions module to define the distribution over the next word.</p>
<p>Transformer language models: These models use a transformer architecture to process the input sequence and generate a probability distribution over the next word in the sequence. You can use Pyro to define a transformer language model by using the pyro.nn module to define the transformer and the pyro.distributions module to define the distribution over the next word.</p>
<p>Variational autoencoder (VAE) language models: These models use a VAE to learn a latent representation of the input sequence, and then use the latent representation to generate a probability distribution over the next word in the sequence. You can use Pyro to define a VAE language model by using the pyro.nn module to define the VAE and the pyro.distributions module to define the distribution over the next word.</p>
<p>To use any of these models with Pyro, you will need to define a probabilistic model that takes in some input data and generates text, and then use Monte Carlo sampling or variational inference to generate text from the model. You can also define a loss function and use an optimization algorithm like Adam to optimize the parameters of the model.</p>
<p>I hope this helps! Let me know if you have any questions.</p>
</section>
<section id="determine-topic-among-a-large-group-of-entities-with-labels-with-pyro" class="level2">
<h2 class="anchored" data-anchor-id="determine-topic-among-a-large-group-of-entities-with-labels-with-pyro">determine topic among a large group of entities with labels with pyro</h2>
<p>To determine the topic among a large group of entities with labels using Pyro, you can use a technique called topic modeling. Pyro is a probabilistic programming language that allows you to build and perform inference on probabilistic models.</p>
<p>One way to perform topic modeling using Pyro is to use a probabilistic graphical model called a Latent Dirichlet Allocation (LDA) model. In an LDA model, you can specify the number of topics and the number of words in each topic, and the model will learn the distribution of words that are likely to belong to each topic.</p>
<p>To implement an LDA model in Pyro, you will first need to define the model and the priors for the parameters. This can be done using the pyro.sample() function, which allows you to specify the probability distribution for the parameters. You can then use the pyro.infer.MCMC() function to perform Markov Chain Monte Carlo (MCMC) inference on the model, which will allow you to estimate the posterior distribution of the model parameters.</p>
<p>Once you have trained the model, you can use it to classify a new document by using the pyro.predict() function and passing in the document’s words as input. The model will return the probability that the document belongs to each of the specified topics.</p>
<p>For more detailed information on how to implement topic modeling using Pyro, you can refer to the Pyro documentation or tutorials online.</p>
</section>
<section id="how-to-determine-watermark-location-and-remove-watermark-at-location-with-several-screenshots-in-a-video-with-pytorch" class="level2">
<h2 class="anchored" data-anchor-id="how-to-determine-watermark-location-and-remove-watermark-at-location-with-several-screenshots-in-a-video-with-pytorch">how to determine watermark location and remove watermark at location with several screenshots in a video with pytorch</h2>
<p>To determine the location of a watermark in a video with multiple screenshots and remove the watermark using PyTorch, you can use a technique called image inpainting. Image inpainting is a process of filling in missing or damaged pixels in an image or video to restore it to its original form.</p>
<p>One way to perform image inpainting using PyTorch is to use a convolutional neural network (CNN) to learn the structure and patterns in the image or video. You can train the CNN to predict the missing or damaged pixels based on the surrounding pixels.</p>
<p>To implement image inpainting using PyTorch, you will need to first prepare a dataset of images or video frames with and without the watermark. You can then use this dataset to train the CNN using the PyTorch API. You can use the PyTorch optimizers and loss functions to optimize the network and improve its performance.</p>
<p>Once the CNN is trained, you can use it to predict the missing or damaged pixels in a new image or video frame with a watermark. You can then remove the watermark by replacing the predicted pixels with the original pixels from the image or video frame without the watermark.</p>
<p>For more detailed information on how to implement image inpainting using PyTorch, you can refer to the PyTorch documentation or tutorials online.</p>
</section>
<section id="how-to-determine-watermark-location-in-a-series-of-screenshots-in-video-with-pytorch" class="level2">
<h2 class="anchored" data-anchor-id="how-to-determine-watermark-location-in-a-series-of-screenshots-in-video-with-pytorch">how to determine watermark location in a series of screenshots in video with pytorch</h2>
<p>To determine the location of a watermark in a series of screenshots in a video using PyTorch, you can use a technique called object detection. Object detection is a process of identifying and localizing objects in an image or video.</p>
<p>One way to perform object detection using PyTorch is to use a convolutional neural network (CNN) to learn the features and patterns in the image or video. You can train the CNN to predict the presence and location of objects in the image or video.</p>
<p>To implement object detection using PyTorch, you will need to first prepare a dataset of images or video frames with and without the watermark. You can then use this dataset to train the CNN using the PyTorch API. You can use the PyTorch optimizers and loss functions to optimize the network and improve its performance.</p>
<p>Once the CNN is trained, you can use it to detect the presence and location of the watermark in a new image or video frame. You can then use the predicted bounding box coordinates to determine the location of the watermark in the image or video frame.</p>
<p>For more detailed information on how to implement object detection using PyTorch, you can refer to the PyTorch documentation or tutorials online.</p>
</section>
<section id="the-data-is-a-series-of-images-not-a-single-image" class="level2">
<h2 class="anchored" data-anchor-id="the-data-is-a-series-of-images-not-a-single-image">the data is a series of images, not a single image</h2>
<p>If you have a series of images and you want to determine the location of a watermark in each of the images using PyTorch, you can use a technique called object detection. Object detection is a process of identifying and localizing objects in an image or video.</p>
<p>One way to perform object detection using PyTorch is to use a convolutional neural network (CNN) to learn the features and patterns in the images. You can train the CNN to predict the presence and location of objects in the images.</p>
<p>To implement object detection using PyTorch, you will need to first prepare a dataset of images with and without the watermark. You can then use this dataset to train the CNN using the PyTorch API. You can use the PyTorch optimizers and loss functions to optimize the network and improve its performance.</p>
<p>Once the CNN is trained, you can use it to detect the presence and location of the watermark in each of the images in the series. You can then use the predicted bounding box coordinates to determine the location of the watermark in each image.</p>
<p>For more detailed information on how to implement object detection using PyTorch, you can refer to the PyTorch documentation or tutorials online.</p>
</section>
<section id="how-to-put-a-series-of-image-into-a-single-cnn-show-me-the-code" class="level2">
<h2 class="anchored" data-anchor-id="how-to-put-a-series-of-image-into-a-single-cnn-show-me-the-code">how to put a series of image into a single CNN, show me the code</h2>
<p>To put a series of images into a single CNN using PyTorch, you can use the PyTorch Dataset and DataLoader classes. These classes allow you to create a custom dataset and load the data in small batches for training or inference.</p>
<p>Here is an example of how you can create a custom dataset for a series of images and use it with a CNN in PyTorch:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> os</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> torch.utils.data <span class="im">import</span> Dataset, DataLoader</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> ImageDataset(Dataset):</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, root_dir, transform<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="va">self</span>.root_dir <span class="op">=</span> root_dir</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="va">self</span>.transform <span class="op">=</span> transform</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="va">self</span>.image_names <span class="op">=</span> os.listdir(<span class="va">self</span>.root_dir)</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> <span class="fu">__len__</span>(<span class="va">self</span>):</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="cf">return</span> <span class="bu">len</span>(<span class="va">self</span>.image_names)</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> <span class="fu">__getitem__</span>(<span class="va">self</span>, idx):</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>image_name <span class="op">=</span> <span class="va">self</span>.image_names[idx]</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>image_path <span class="op">=</span> os.path.join(<span class="va">self</span>.root_dir, image_name)</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>image <span class="op">=</span> Image.<span class="bu">open</span>(image_path).convert(<span class="st">'RGB'</span>)</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="va">self</span>.transform:</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>image <span class="op">=</span> <span class="va">self</span>.transform(image)</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a><span class="cf">return</span> image</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Create the dataset and dataloader</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>dataset <span class="op">=</span> ImageDataset(root_dir<span class="op">=</span><span class="st">'path/to/images'</span>)</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>dataloader <span class="op">=</span> DataLoader(dataset, batch_size<span class="op">=</span><span class="dv">32</span>, shuffle<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a><span class="co"># Define the CNN model</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> CNN(torch.nn.Module):</span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a><span class="bu">super</span>(CNN, <span class="va">self</span>).<span class="fu">__init__</span>()</span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a><span class="va">self</span>.conv1 <span class="op">=</span> torch.nn.Conv2d(<span class="dv">3</span>, <span class="dv">6</span>, <span class="dv">5</span>)</span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a><span class="va">self</span>.pool <span class="op">=</span> torch.nn.MaxPool2d(<span class="dv">2</span>, <span class="dv">2</span>)</span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a><span class="va">self</span>.conv2 <span class="op">=</span> torch.nn.Conv2d(<span class="dv">6</span>, <span class="dv">16</span>, <span class="dv">5</span>)</span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a><span class="va">self</span>.fc1 <span class="op">=</span> torch.nn.Linear(<span class="dv">16</span> <span class="op">*</span> <span class="dv">5</span> <span class="op">*</span> <span class="dv">5</span>, <span class="dv">120</span>)</span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a><span class="va">self</span>.fc2 <span class="op">=</span> torch.nn.Linear(<span class="dv">120</span>, <span class="dv">84</span>)</span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a><span class="va">self</span>.fc3 <span class="op">=</span> torch.nn.Linear(<span class="dv">84</span>, <span class="dv">10</span>)</span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> forward(<span class="va">self</span>, x):</span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> <span class="va">self</span>.pool(F.relu(<span class="va">self</span>.conv1(x)))</span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> <span class="va">self</span>.pool(F.relu(<span class="va">self</span>.conv2(x)))</span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> x.view(<span class="op">-</span><span class="dv">1</span>, <span class="dv">16</span> <span class="op">*</span> <span class="dv">5</span> <span class="op">*</span> <span class="dv">5</span>)</span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> F.relu(<span class="va">self</span>.fc1(x))</span>
<span id="cb3-36"><a href="#cb3-36" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> F.relu(<span class="va">self</span>.fc2(x))</span>
<span id="cb3-37"><a href="#cb3-37" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> <span class="va">self</span>.fc3(x)</span>
<span id="cb3-38"><a href="#cb3-38" aria-hidden="true" tabindex="-1"></a><span class="cf">return</span> x</span>
<span id="cb3-39"><a href="#cb3-39" aria-hidden="true" tabindex="-1"></a><span class="co"># Create the model and optimizer</span></span>
<span id="cb3-40"><a href="#cb3-40" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> CNN()</span>
<span id="cb3-41"><a href="#cb3-41" aria-hidden="true" tabindex="-1"></a>optimizer <span class="op">=</span> torch.optim.SGD(model.parameters(), lr<span class="op">=</span><span class="fl">0.001</span>, momentum<span class="op">=</span><span class="fl">0.9</span>)</span>
<span id="cb3-42"><a href="#cb3-42" aria-hidden="true" tabindex="-1"></a><span class="co"># Loop through the dataloader and train the model</span></span>
<span id="cb3-43"><a href="#cb3-43" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> images, labels <span class="kw">in</span> dataloader:</span>
<span id="cb3-44"><a href="#cb3-44" aria-hidden="true" tabindex="-1"></a>optimizer.zero_grad()</span>
<span id="cb3-45"><a href="#cb3-45" aria-hidden="true" tabindex="-1"></a>outputs <span class="op">=</span> model(images)</span>
<span id="cb3-46"><a href="#cb3-46" aria-hidden="true" tabindex="-1"></a>loss <span class="op">=</span> criterion(outputs, labels)</span>
<span id="cb3-47"><a href="#cb3-47" aria-hidden="true" tabindex="-1"></a>loss.backward()</span>
<span id="cb3-48"><a href="#cb3-48" aria-hidden="true" tabindex="-1"></a>optimizer.step()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>In this example, the ImageDataset class extends the PyTorch Dataset class and is used to load the images from a root directory. The DataLoader class is used to load the data in small batches and shuffle</p>
</section>
<section id="use-pyro-to-generate-natural-language" class="level2">
<h2 class="anchored" data-anchor-id="use-pyro-to-generate-natural-language">use pyro to generate natural language</h2>
<p>To generate natural language using Pyro, you can use a technique called language modeling. Language modeling is the process of predicting the next word in a sequence of words given the previous words.</p>
<p>One way to perform language modeling using Pyro is to use a probabilistic graphical model called a recurrent neural network (RNN) language model. In an RNN language model, the probability of each word in the sequence is modeled as a function of the previous words in the sequence.</p>
<p>To implement an RNN language model in Pyro, you will first need to define the model and the priors for the parameters. This can be done using the pyro.sample() function, which allows you to specify the probability distribution for the parameters. You can then use the pyro.infer.SVI() function to perform stochastic variational inference on the model, which will allow you to estimate the posterior distribution of the model parameters.</p>
<p>Once you have trained the model, you can use it to generate natural language by feeding it a seed word or phrase and using the model to predict the next word in the sequence. You can then use the predicted word as the input for the next iteration, and continue generating the sequence until you reach the desired length.</p>
<p>For more detailed information on how to implement language modeling using Pyro, you can refer to the Pyro documentation or tutorials online.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>